
<html>
<html>

<body>

<div>
	<h3>Text to Line Art Image</h3>

	<p>
		Draw a set of connected lines using the pipe, hyphen, and plus-sign characters,
		then click the button to convert them to a line-art image.
	</p>

	<div>
		<label>Lines as Text:<label>
		<button onclick="buttonDemo_Clicked()">Load Demo</button>
		<br />
		<textarea
			id="textareaLinesAsText"
			cols="80" rows="25"
			spellcheck="false"
		></textarea>
	</div>

	<div>
		<button onclick="buttonConvertTextToImage_Clicked()">Convert</button>
	</div>

	<div>
		<label>Image:</label>
		<div id="divLinesAsImage">
			[none]
		</div>
	</div>

</div>

<script type="text/javascript">

function buttonConvertTextToImage_Clicked()
{
	var d = document;
	var textareaLinesAsText =
		d.getElementById("textareaLinesAsText");
	var linesAsText = textareaLinesAsText.value;

	var converter = new TextToLineArtImageConverter();

	var cellDimensionInPixels = 16; // todo - Make configurable.

	var linesAsCanvas =
		converter.textToCanvas(linesAsText, cellDimensionInPixels);

	var divLinesAsImage =
		d.getElementById("divLinesAsImage");
	divLinesAsImage.innerHTML = "";
	divLinesAsImage.appendChild(linesAsCanvas);
}

function buttonDemo_Clicked()
{
	var linesAsStrings = 
	[
		"         ",
		" +-+ +-+ ",
		" | | | | ",
		" | +-+ | ",
		" |     | ",
		" | +-+ | ",
		" | | | | ",
		" +-+ +-+ ",
		"         "
	];

	var newline = "\n";
	var linesAsString = linesAsStrings.join(newline);

	var d = document;
	var textareaLinesAsText =
		d.getElementById("textareaLinesAsText");
	textareaLinesAsText.value = linesAsString;
}

class Coords
{
	constructor(x, y)
	{
		this.x = x;
		this.y = y;
	}

	static create()
	{
		return new Coords(0, 0);
	}

	static fromXY(x, y)
	{
		return new Coords(x, y);
	}

	clone()
	{
		return new Coords(this.x, this.y);
	}

	multiply(other)
	{
		this.x *= other.x;
		this.y *= other.y;
		return this;
	}

	multiplyScalar(scalar)
	{
		this.x *= scalar;
		this.y *= scalar;
		return this;
	}

	overwriteWith(other)
	{
		this.x = other.x;
		this.y = other.y;
		return this;
	}
}

class Edge
{
	constructor(vertices)
	{
		this.vertices = vertices;
	}

	static fromVertices(vertex0, vertex1)
	{
		return new Edge( [ vertex0, vertex1 ] );
	}
}

class TextToLineArtImageConverter
{
	textToCanvas(edgesAsString, cellDimensionInPixels)
	{
		var newline = "\n";
		var cellRowsAsStrings = edgesAsString.split(newline);

		var sizeInCells = Coords.fromXY
		(
			cellRowsAsStrings[0].length,
			cellRowsAsStrings.length
		);

		var charCodeCorner = "+";
		var charCodeHorizontal = "-";
		var charCodeVertical = "|";

		var edgesSoFar = [];

		var cellPos = Coords.create();
		var cornerPosPrev = null;

		// Horizontal.

		for (var y = 0; y < sizeInCells.y; y++)
		{
			cellPos.y = y;

			var cellRowAsString = cellRowsAsStrings[y];

			for (var x = 0; x < sizeInCells.x; x++)
			{
				cellPos.x = x;

				var cellAsChar = cellRowAsString[x];

				var edgeIsInProgress = (cornerPosPrev != null);

				if (edgeIsInProgress)
				{
					if (cellAsChar == charCodeCorner)
					{
						var edge = Edge.fromVertices(cornerPosPrev, cellPos.clone() );
						edgesSoFar.push(edge);
						cornerPosPrev = null;
					}
					else if (cellAsChar == charCodeHorizontal)
					{
						// Do nothing.
					}
					else
					{
						this.throwFormatError();
					}
				}
				else if (cellAsChar == charCodeCorner)
				{
					cornerPosPrev = cellPos.clone();
				}
			}
		}

		// Vertical.

		for (var x = 0; x < sizeInCells.x; x++)
		{
			cellPos.x = x;

			for (var y = 0; y < sizeInCells.y; y++)
			{
				cellPos.y = y;

				var cellRowAsString = cellRowsAsStrings[y];
				var cellAsChar = cellRowAsString[x];

				var edgeIsInProgress = (cornerPosPrev != null);

				if (edgeIsInProgress)
				{
					if (cellAsChar == charCodeCorner)
					{
						var edge = Edge.fromVertices(cornerPosPrev, cellPos.clone() );
						edgesSoFar.push(edge);
						cornerPosPrev = null;
					}
					else if (cellAsChar == charCodeVertical)
					{
						// Do nothing.
					}
					else
					{
						this.throwFormatError();
					}
				}
				else if (cellAsChar == charCodeCorner)
				{
					cornerPosPrev = cellPos.clone();
				}
			}
		}

		// todo - Diagonals.

		// Draw the edges to a canvas.

		var cellSizeInPixels =
			Coords.fromXY(1, 1).multiplyScalar(cellDimensionInPixels);
		var imageSizeInPixels =
			sizeInCells.clone().multiply(cellSizeInPixels);

		var d = document;
		var canvas = d.createElement("canvas");
		canvas.width = imageSizeInPixels.x;
		canvas.height = imageSizeInPixels.y;

		var graphics = canvas.getContext("2d");
		graphics.strokeStyle = "DarkGray";

		var pixelPos = Coords.create();

		for (var e = 0; e < edgesSoFar.length; e++)
		{
			var edge = edgesSoFar[e];

			var edgeVertices = edge.vertices;
			var edgeVertex0 = edgeVertices[0];
			var edgeVertex1 = edgeVertices[1];

			graphics.beginPath();
			pixelPos
				.overwriteWith(edgeVertex0)
				.multiply(cellSizeInPixels);
			graphics.moveTo(pixelPos.x, pixelPos.y);
			pixelPos
				.overwriteWith(edgeVertex1)
				.multiply(cellSizeInPixels);
			graphics.lineTo(pixelPos.x, pixelPos.y);
			graphics.stroke();
		}

		return canvas;
	}

	throwFormatError()
	{
		throw new Error("Format error.");
	}
}

</script>

</body>

</html>